<script>
  function onLoad() {
    // On initial load of inventory, make sure filterList is not null
    if (
      record?.data?.filterList === undefined ||
      record?.data?.filterList === null ||
      record?.data?.filterByLocation === undefined ||
      record?.data?.filterByLocation === null
    ) {
      api.setValues({
        "data.filterList": "",
        "data.filterByLocation": "",
      });
    }
  }

  function onDropItem(recordLink) {
    const item = recordLink?.value;

    const isConsumable = item?.data?.consumable || false;
    const hasUseBtn = item?.data?.hasUseBtn || false;

    let unitCount = item.data?.count || 1;
    // Add the item and set the attunement hidden field to visible if requires attunement
    const itemToAdd = {
      ...item,
      icon: "IconBox",
      data: {
        ...item?.data,
        // Track old ID for count tracking
        fromId: item._id,
        // Default count to 1
        count: unitCount,
      },
      fields: {
        ...item?.fields,
        useBtn: {
          hidden: !isConsumable && !hasUseBtn,
        },
      },
    };

    // Determine if we are adding the item or adding count to an existing item
    const items = record?.data?.inventory || [];
    const index = items.findIndex((i) => i.data?.fromId === item._id);

    // If the item is an item pack, we're adding a list of items
    if (item.data?.type === "pack") {
      // Get the total weight of all items in the pack
      const itemsInPack = item.data?.items || [];
      const valuesToSet = {};
      // Add any currency in pack to character
      valuesToSet["data.cash"] =
        (record?.data?.cash || 0) + (item.data?.cash || 0);
      const itemsToAdd = itemsInPack
        .map((item) => {
          // If this is existing item, get the current count
          let thisIndex = items.findIndex((i) => i.data?.fromId === item._id);
          let existingItem = thisIndex !== -1 ? items[thisIndex] : undefined;
          let itemCount = parseFloat(item?.data?.count || "0");
          const isConsumable = item.data?.consumable || false;
          let curCount = parseFloat(existingItem?.data?.count || "0");
          if (!existingItem) {
            return {
              ...item,
              icon: "IconBox",
              data: {
                ...item.data,
                fromId: item._id,
                count: itemCount,
              },
              fields: {
                ...item?.fields,
                useBtn: {
                  hidden: !isConsumable && !hasUseBtn,
                },
              },
            };
          } else {
            valuesToSet[`data.inventory.${thisIndex}.data.count`] =
              curCount + itemCount;
          }
        })
        .filter((i) => i);
      api.addValues(`data.inventory`, itemsToAdd, (updatedRecord) => {
        if (Object.keys(valuesToSet).length > 0) {
          api.setValues(valuesToSet, () => {
            // Requery the record to get the latest data
            api.getRecord(record.recordType, record._id, (record2) => {
              setTotalEncumbrance(record2);
            });
          });
        } else {
          api.getRecord(record.recordType, record._id, (record2) => {
            setTotalEncumbrance(record2);
          });
        }
      });
    } else {
      let existingItem = index !== -1 ? items[index] : undefined;
      if (existingItem) {
        // Add count to existing item
        const count = parseFloat(existingItem.data?.count || "0");
        let unitCount = parseFloat(item.data?.count || "1");
        // Update the value
        api.setValue(
          `data.inventory.${index}.data.count`,
          count + unitCount,
          (record) => {
            setTotalEncumbrance(record);
          }
        );
      } else {
        // Add the item to the list
        api.addValue(`data.inventory`, itemToAdd, (record) => {
          setTotalEncumbrance(record);
        });
      }
    }
  }

  function onDrop(type, recordLink, sourceInfo) {
    if (type === "items") {
      onDropItem(recordLink);
      if (sourceInfo) {
        if (sourceInfo?.type === "list") {
          // Query for the record first, then remove the item from the source list
          api.getRecord(
            sourceInfo.recordType,
            sourceInfo.recordId,
            (sourceRecord) => {
              api.removeValueFromRecord(
                sourceRecord,
                sourceInfo.dataPath,
                sourceInfo.index
              );
            }
          );
        } else if (sourceInfo?.type === "partysheet") {
          // Remove the item from party sheet
          api.removePartySheetItem(sourceInfo.itemId);
        }
      }
    }
  }

  function onItemDeleted() {
    // Update attributes as per modifiers
    const valuesToSet = {};
    setTotalEncumbrance(record, valuesToSet);
    updateAttributes(record, valuesToSet);
    if (Object.keys(valuesToSet).length > 0) {
      api.setValues(valuesToSet);
    }
  }

  function getLocations() {
    const inventory = record?.data?.inventory || [];
    const locations = inventory.map((item) => item.data?.location || "");
    // Filter out duplicates by creating a Set and converting back to array
    // Also filter out empty strings
    const uniqueLocations = [...new Set(locations)].filter(
      (location) => location !== ""
    );

    // Always include the "All" option at the beginning
    return [
      { value: "", label: "All" },
      ...uniqueLocations.map((location) => ({
        value: location,
        label: location,
      })),
    ];
  }

  function addCurrency() {
    // Delay to ensure field values are updated before processing
    api.delay(() => {
      api.getRecord(record.recordType, record._id, (record2) => {
        const addAmount = parseInt(record2?.data?.addCash || "0") || 0;
        const newCash = (record2?.data?.cash || 0) + addAmount;

        api.setValues({
          "data.cash": newCash,
          "data.addCash": "",
        });
        api.closeOpenedPopovers();
      });
    }, 300);
  }

  function deductCurrency() {
    // Delay to ensure field values are updated before processing
    api.delay(() => {
      api.getRecord(record.recordType, record._id, (record2) => {
        const deductAmount = parseInt(record2?.data?.deductCash || "0") || 0;
        const currentCash = record2?.data?.cash || 0;

        if (deductAmount > currentCash) {
          api.showNotification("Not enough money!", "red", "Not Enough Money");
          return;
        }

        const newCash = currentCash - deductAmount;

        api.setValues({
          "data.cash": newCash,
          "data.deductCash": "",
        });
        api.closeOpenedPopovers();
      });
    }, 300);
  }
</script>

<div>
  <label variant="bold" textalign="center" label="Inventory"></label>
</div>

<div style="display: flex; flex-direction: row; gap: 4px">
  <dropdown
    field="filterList"
    label="Filter by Type"
    onload="onLoad()"
    size="xs"
    disablediflocked="false"
    defaultvalue=""
    options='[{"label": "All", "value": ""}, {"label": "General", "value": "general"}, {"label": "Melee Weapon", "value": "melee weapon"}, {"label": "Ranged Weapon", "value": "ranged weapon"}, {"label": "Armor", "value": "armor"}, {"label": "Weapon Attachment", "value": "weapon attachment"}, {"label": "Armor Attachment", "value": "armor attachment"}]'
  ></dropdown>
  <dropdown
    field="filterByLocation"
    label="Filter by Location"
    size="xs"
    defaultvalue=""
    placeholder="Select Location..."
    optionsFunction="return getLocations();"
    disablediflocked="false"
  ></dropdown>
  <div
    style="
      margin-left: auto;
      display: flex;
      flex-direction: row;
      gap: 4px;
      align-items: flex-end;
    "
  >
    <numberfield
      width="100px"
      size="xs"
      placeholder="0"
      field="cash"
      label="Money"
    ></numberfield>
    <popover position="bottom" offset="4" witharrow="true">
      <popover.target>
        <iconbutton
          size="md"
          variant="default"
          hideonlocked="true"
          options='[{"icon": "IconPlus", "label": "Add Money", "value": "add"}]'
          field="addCurrencyBtn"
        ></iconbutton>
      </popover.target>
      <popover.dropdown>
        <div
          style="display: flex; flex-direction: column; gap: 4px; width: 150px"
        >
          <label size="xs" variant="bold" label="Add Money"></label>
          <numberfield
            placeholder="0"
            field="addCash"
            width="100%"
            disablediflocked="false"
          ></numberfield>
          <button
            size="xs"
            variant="outline"
            label="Add"
            onclick="addCurrency();"
          ></button>
        </div>
      </popover.dropdown>
    </popover>
    <popover position="bottom" offset="4" witharrow="true">
      <popover.target>
        <iconbutton
          size="md"
          variant="default"
          hideonlocked="true"
          options='[{"icon": "IconMinus", "label": "Deduct Money", "value": "deduct"}]'
          field="deductCurrencyBtn"
        ></iconbutton>
      </popover.target>
      <popover.dropdown>
        <div
          style="display: flex; flex-direction: column; gap: 4px; width: 150px"
        >
          <label size="xs" variant="bold" label="Deduct Money"></label>
          <numberfield
            placeholder="0"
            field="deductCash"
            width="100%"
            disablediflocked="false"
          ></numberfield>
          <button
            size="xs"
            variant="outline"
            label="Deduct"
            onclick="deductCurrency();"
          ></button>
        </div>
      </popover.dropdown>
    </popover>
  </div>
</div>

<div style="display: flex; flex-direction: row; margin-top: 8px">
  <div style="margin-left: 34px">
    <label variant="bold" size="xs" textalign="left" label="Count"></label>
  </div>
  <div style="margin-left: 30px; flex-grow: 1">
    <label variant="bold" size="xs" textalign="left" label="Item"></label>
  </div>
  <div
    style="
      margin-left: 4px;
      max-width: 100px;
      min-width: 68px;
      flex: 1;
      display: flex;
    "
  >
    <label variant="bold" size="xs" textalign="left" label="Location"></label>
  </div>
  <div
    style="
      margin-left: 4px;
      max-width: 95px;
      min-width: 65px;
      flex: 1;
      display: flex;
    "
  >
    <label variant="bold" size="xs" textalign="left" label="Equipped"></label>
  </div>
  <box field="spacerRight" hideonlocked="true">
    <div style="width: 16px"></div>
  </box>
</div>

<div style="display: flex; flex-direction: column; flex-grow: 1">
  <list
    listtype="inventory_list"
    radius="none"
    variant="striped"
    field="inventory"
    onchange="onItemDeleted();"
  >
  </list>
</div>

<div style="display: flex; flex-direction: row; width: 100%; gap: 4px">
  <numberfield
    size="xs"
    placeholder="0"
    field="encumbrance"
    label="Total Encumbrance"
  ></numberfield>
  <numberfield
    size="xs"
    placeholder="0"
    field="encumbranceThreshold"
    label="Encumbrance Threshold"
  ></numberfield>
  <numberfield
    size="xs"
    placeholder="0"
    field="healingUsed"
    label="Healing Items Used Today"
  ></numberfield>
</div>
